use candid::Nat;
use candid::Principal;
use leptos::prelude::*;
use rand::{rngs::SmallRng, Rng, SeedableRng};
use yral_canisters_client::individual_user_template::{Result7, SessionType};
use yral_canisters_common::Canisters;
use yral_spacetime_bindings::{
    autogenerated::backend::DolrAirdropInfoTableAccess,
    spacetimedb_sdk::{TimeDuration, Timestamp},
};

use crate::wallet::airdrop::AirdropStatus;

const DOLR_AIRDROP_LIMIT_DURATION: web_time::Duration = web_time::Duration::from_secs(24 * 3600);
const MAX_AIRDROP_COUNT_WITHIN_DURATION: u64 = 1;
/// in e0s
const DOLR_AIRDROP_AMOUNT_RANGE: std::ops::Range<u64> = 5..10;

/// returns either ok, or the how long after which airdrop will be available
async fn is_dolr_airdrop_available(
    _user_canister: Principal,
    user_principal: Principal,
    now: web_time::SystemTime,
) -> Result<(), web_time::Duration> {
    let ctx: state::stdb_dolr_airdrop::WrappedContext = expect_context();

    let Some(airdrop_info) = ctx
        .conn
        .db
        .dolr_airdrop_info()
        .user_principal()
        .find(&user_principal.to_text())
    else {
        // user has never claimed airdrop before
        return Ok(());
    };

    let now: Timestamp = now.into();
    let next_airdrop_available_after =
        airdrop_info.last_airdrop_at + TimeDuration::from_duration(DOLR_AIRDROP_LIMIT_DURATION);

    if now < next_airdrop_available_after {
        let count = airdrop_info.airdrop_count_within_duration + 1;
        if count > MAX_AIRDROP_COUNT_WITHIN_DURATION {
            return Err(next_airdrop_available_after
                .duration_since(now)
                .expect("now is less than after"));
        }
    }

    Ok(())
}

#[server(input = server_fn::codec::Json)]
pub async fn is_user_eligible_for_dolr_airdrop(
    user_canister: Principal,
    user_principal: Principal,
) -> Result<AirdropStatus, ServerFnError> {
    let res =
        is_dolr_airdrop_available(user_canister, user_principal, web_time::SystemTime::now()).await;

    match res {
        Ok(_) => Ok(AirdropStatus::Available),
        Err(duration) => Ok(AirdropStatus::WaitFor(duration)),
    }
}

#[cfg(not(feature = "backend-admin"))]
pub async fn send_airdrop_to_user(
    _user_principal: Principal,
    _amount: Nat,
) -> Result<(), ServerFnError> {
    log::error!("trying to send dolr but no backend admin is available");

    Err(ServerFnError::new("backend admin not available"))
}

#[cfg(feature = "backend-admin")]
pub async fn send_airdrop_to_user(
    user_principal: Principal,
    amount: Nat,
) -> Result<(), ServerFnError> {
    use consts::DOLR_AI_LEDGER_CANISTER;
    use state::admin_canisters::AdminCanisters;
    use yral_canisters_client::sns_ledger::{Account, SnsLedger, TransferResult};
    let admin: AdminCanisters = expect_context();

    let ledger = SnsLedger(
        DOLR_AI_LEDGER_CANISTER.parse().unwrap(),
        admin.get_agent().await,
    );

    let res = ledger
        .icrc_1_transfer(yral_canisters_client::sns_ledger::TransferArg {
            to: Account {
                owner: user_principal,
                subaccount: None,
            },
            fee: None,
            memo: None,
            from_subaccount: None,
            created_at_time: None,
            amount,
        })
        .await?;

    if let TransferResult::Err(err) = res {
        return Err(ServerFnError::new(format!("transfer failed: {err:?}")));
    }

    Ok(())
}

#[server(input = server_fn::codec::Json)]
pub async fn claim_dolr_airdrop(
    user_canister: Principal,
    user_principal: Principal,
) -> Result<u64, ServerFnError> {
    let cans: Canisters<false> = expect_context();
    let user = cans.individual_user(user_canister).await;
    let profile_owner = user.get_profile_details_v_2().await?;
    if profile_owner.principal_id != user_principal {
        // ideally should never happen unless its a hacking attempt
        println!(
            "Not allowed to claim due to principal mismatch: owner={} != receiver={user_principal}",
            profile_owner.principal_id,
        );
        return Err(ServerFnError::new(
            "Not allowed to claim: principal mismatch",
        ));
    }

    let sess = user.get_session_type().await?;
    if !matches!(sess, Result7::Ok(SessionType::RegisteredSession)) {
        // log::error!("Not allowed to claim: not logged in");
        return Err(ServerFnError::new("Not allowed to claim: not logged in"));
    }

    let now = web_time::SystemTime::now();
    if is_dolr_airdrop_available(user_canister, user_principal, now)
        .await
        .is_err()
    {
        return Err(ServerFnError::new(
            "Not allowed to claim: max claims reached within allowed duration",
        ));
    }

    let ctx: state::stdb_dolr_airdrop::WrappedContext = expect_context();

    ctx.mark_airdrop_claimed(user_principal, DOLR_AIRDROP_LIMIT_DURATION, now)
        .await
        .map_err(ServerFnError::new)?
        // this is not likely to happen with current impl on stdb, but good to
        // be cautious
        .map_err(ServerFnError::new)?;

    let mut rng = SmallRng::from_os_rng();
    let amount = rng.random_range(DOLR_AIRDROP_AMOUNT_RANGE);
    let e8s_amount: Nat = Nat::from(amount) * (1e8 as usize);
    // sending money _after_ marking claim with reasoning "a couple unhappy users
    // are better than company losing money"
    send_airdrop_to_user(user_principal, e8s_amount).await?;

    Ok(amount)
}
